Talks: What makes a Python debugger possible and how can we make it 100x faster Friday - May 17th, 2024 11:45 a.m.-12:15 p.m. in Room 301-305   Presented by:  Tian Gao  Description Many of us use debuggers, from the basic standard library pdb to many other fancier alternatives, but what makes it possible to debug Python code? Have you ever wondered why the entry function of pdb is named pdb.set_trace()? To make a basic debugger, you need to be able to: * Stop the program at a certain position * View as much information as possible in a convenient way * Evaluate expressions and even run arbitrary code * Control the program execution How does Python debugger like pdb achieve this? We will discuss the magic of sys.settrace, and the rich runtime information Python provides. However, there's still a pitfall. The mechanism introduces a huge overhead in order to achieve features like breakpoints. Can we do something about it? Can we have a overhead-free debugger that can do exactly what pdb can do now? It becomes possible with PEP 669, the low-cost monitoring system introduced in Python 3.12. We will talk about the difference between the current mechanism based on sys.settrace and PEP 669, or sys.monitoring. With proper implementation, we can achieve 100x speed up for breakpoints.        