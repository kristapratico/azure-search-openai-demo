Talks: How Python Harnesses Rust through PyO3 Saturday - May 18th, 2024 1:30 p.m.-2:15 p.m. in Room 301-305   Presented by:  David Hewitt  Description The last few years have seen Rust burst onto the scene as a language for implementing much-loved software for the Python ecosystem. The most well known examples of these are pydantic, polars, cryptography, and ruff. These Rust components are usually built on top of PyO3, a Rust library for binding the two languages together, and maturin, a PEP517 build backend for Rust software. There are a growing number of talks, blogs, and guides showing how to use these tools. In this talk I'll lead you through the details of how a Python function call ends up executing Rust code via PyO3. We'll first spend some time introducing some key ideas as well as the benefits of adding Rust to your Python stack. I'll then break down step-by-step what happens inside the Python interpreter and PyO3's internals as a seemingly simple enough Python expression leads to execution of your Rust function. You should walk away from this talk with an idea of how Rust/PyO3 software works under the hood. These same stages of a "native" function call are similar for multiple other languages too, including Python standard library "builtins", Cython code, and C++/pybind11 software, so this may bring you some useful insight even if Rust is not planned to be in your software stack soon. While this talk will get technical, no knowledge of Rust will be assumed. An understanding of Python functions and types will be useful, as I'll use these to introduce the analogous Rust concepts. Expect to see Rust code (and maybe a little C), but only for illustration - all code will be broken down and stepped through.        